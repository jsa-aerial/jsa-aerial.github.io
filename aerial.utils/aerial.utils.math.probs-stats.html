<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>aerial.utils.math.probs-stats documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Aerial.utils</span> <span class="project-version">1.0.9</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to utils</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aerial</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></div></li><li class="depth-3 branch"><a href="aerial.utils.coll.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coll</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ds</span></div></div></li><li class="depth-4 branch"><a href="aerial.utils.ds.bktrees.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bktrees</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.ds.graphs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graphs</span></div></a></li><li class="depth-4"><a href="aerial.utils.ds.trees.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>trees</span></div></a></li><li class="depth-3 branch"><a href="aerial.utils.io.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-3"><a href="aerial.utils.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.clustering.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clustering</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.combinatorics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combinatorics</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.infoth.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>infoth</span></div></a></li><li class="depth-4 branch current"><a href="aerial.utils.math.probs-stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>probs-stats</span></div></a></li><li class="depth-4"><a href="aerial.utils.math.scores.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scores</span></div></a></li><li class="depth-3 branch"><a href="aerial.utils.misc.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>misc</span></div></a></li><li class="depth-3"><a href="aerial.utils.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-alphabet2"><div class="inner"><span>alphabet2</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-avg-std-deviation"><div class="inner"><span>avg-std-deviation</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-avg-variance"><div class="inner"><span>avg-variance</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-binomial-dist"><div class="inner"><span>binomial-dist</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-binomial-pdf"><div class="inner"><span>binomial-pdf</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-combins-freqn"><div class="inner"><span>cc-combins-freqn</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-combins-freqs-probs"><div class="inner"><span>cc-combins-freqs-probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-freqn"><div class="inner"><span>cc-freqn</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-freqs"><div class="inner"><span>cc-freqs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-freqs.26probs"><div class="inner"><span>cc-freqs&amp;probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-freqs-probs"><div class="inner"><span>cc-freqs-probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-tfreqn"><div class="inner"><span>cc-tfreqn</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cc-tfreqs"><div class="inner"><span>cc-tfreqs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-choose-k-freqn"><div class="inner"><span>choose-k-freqn</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-combin-count-reduction"><div class="inner"><span>combin-count-reduction</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-combins-freqn"><div class="inner"><span>combins-freqn</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-combins-freqs-probs"><div class="inner"><span>combins-freqs-probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-cond-probability"><div class="inner"><span>cond-probability</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-correlation"><div class="inner"><span>correlation</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-covariance"><div class="inner"><span>covariance</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-flatten-pair-coll"><div class="inner"><span>flatten-pair-coll</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-freqn"><div class="inner"><span>freqn</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-freqs.26probs"><div class="inner"><span>freqs&amp;probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-freqs-probs"><div class="inner"><span>freqs-probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-geometric-dist"><div class="inner"><span>geometric-dist</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-geometric-pdf"><div class="inner"><span>geometric-pdf</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-joint-prob-x"><div class="inner"><span>joint-prob-x</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-joint-probability"><div class="inner"><span>joint-probability</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-JPSxy"><div class="inner"><span>JPSxy</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-JPxy"><div class="inner"><span>JPxy</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-keysort"><div class="inner"><span>keysort</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-letter-pairs"><div class="inner"><span>letter-pairs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-mean"><div class="inner"><span>mean</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-median"><div class="inner"><span>median</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-num-key-freq-map.3F"><div class="inner"><span>num-key-freq-map?</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-p-value"><div class="inner"><span>p-value</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-pair-coll.3F"><div class="inner"><span>pair-coll?</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-pdsum"><div class="inner"><span>pdsum</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-pearson-correlation"><div class="inner"><span>pearson-correlation</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-poisson-cdf"><div class="inner"><span>poisson-cdf</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-poisson-dist"><div class="inner"><span>poisson-dist</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-poisson-pdf"><div class="inner"><span>poisson-pdf</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-poisson-sample"><div class="inner"><span>poisson-sample</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-probs"><div class="inner"><span>probs</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-pXY.7Cy"><div class="inner"><span>pXY|y</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-sampling"><div class="inner"><span>sampling</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-std-deviation"><div class="inner"><span>std-deviation</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-variance"><div class="inner"><span>variance</span></div></a></li><li class="depth-1"><a href="aerial.utils.math.probs-stats.html#var-word-letter-pairs"><div class="inner"><span>word-letter-pairs</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">aerial.utils.math.probs-stats</h1><div class="doc"><pre class="plaintext">Various frequency, combinatorial, probability, statistical,
measure, and metrics for a variety of sequence and string data.</pre></div><div class="public anchor" id="var-alphabet2"><h3>alphabet2</h3><div class="usage"><code>(alphabet2 coll &amp; {n :n, :or {n 1}})</code></div><div class="doc"><pre class="plaintext">Return the alphabet for coll.  If coll is a map, return it's keys.
If a set, return coll, otherwise return alphabet generated over
coll by freqn with size n.</pre></div></div><div class="public anchor" id="var-avg-std-deviation"><h3>avg-std-deviation</h3><div class="usage"><code>(avg-std-deviation sample-set)</code><code>(avg-std-deviation sample-set {:keys [distfn avgfn v], :or {distfn -, avgfn mean}})</code></div><div class="doc"><pre class="plaintext">Compute the average of the n standard deviations for the n samples
in SAMPLE-SET.  This is not as obvious as it may at first seem.  It
is _not_ the mean of the stdevs of each sample.  The correct
averaging is the sqrt of the average of the weighted variances of
each sample, where the weighting is the sample size.  This latter
is given by avg-variance (see its documentation for details).  So,
we return:

(sqrt (avg-variance sample-set))
</pre></div></div><div class="public anchor" id="var-avg-variance"><h3>avg-variance</h3><div class="usage"><code>(avg-variance sample-set)</code><code>(avg-variance sample-set &amp; {:keys [distfn avgfn m], :or {distfn -, avgfn mean}})</code></div><div class="doc"><pre class="plaintext">Compute the average of the n variances for the n samples in
SAMPLE-SET.  This is not as obvious as it may at first seem.  It is
_not_ the mean of the variances of each sample.  The correct
averaging is the average of the weighted variances of each sample,
where the weighting is the sample size:

(/ (sum (fn[Si] (dec (count Si)) (variance Si)) sample-set)
   (- (sum count sample-set) (count sample-set)))

This does reduce to the mean of the variances if the samples are
all of the same size, but this is often (typically?) not the case.

DISTFN and AVGFN are as for the function variance (for which, see)
</pre></div></div><div class="public anchor" id="var-binomial-dist"><h3>binomial-dist</h3><div class="usage"><code>(binomial-dist N p)</code></div><div class="doc"><pre class="plaintext">Binomial probability distribution. P is the probability of a hit
and N is the number of trials.  Returns a seq of pairs [k pr],
where k in (range 1 (inc N)) and pr is probability of getting k
successes in N trials.
</pre></div></div><div class="public anchor" id="var-binomial-pdf"><h3>binomial-pdf</h3><div class="usage"><code>(binomial-pdf p)</code></div><div class="doc"><pre class="plaintext">Return the binomial probability mass/distribution _function_
corresponding to P, the probability of a hit in some Bernoulli
trial.  The resulting function returned, call it bnpdf, is a
function of two parameters, the number of hits k (successes), and
the number of trials N.  So, if the result of (binomial-pdf 1/4) is
bound to bnpdf, then (bnpdf 3 10) would be the probability of
getting 3 hits in 10 trials for sample probability 1/4.  A
distribution of bnpdf can then be generated via some technique
like (map #(bnpdf % 1000) (range 1 (inc 1000))).
</pre></div></div><div class="public anchor" id="var-cc-combins-freqn"><h3>cc-combins-freqn</h3><div class="usage"><code>(cc-combins-freqn n colls &amp; {par :par, :or {par 1}})</code></div><div class="doc"><pre class="plaintext">combins-freqn over all collections C in colls.  Basically cc-freqs
with freq-fn equal combins-freqn</pre></div></div><div class="public anchor" id="var-cc-combins-freqs-probs"><h3>cc-combins-freqs-probs</h3><div class="usage"><code>(cc-combins-freqs-probs n colls &amp; {par :par, :or {par 1}})</code></div><div class="doc"><pre class="plaintext">cc-freqs&amp;probs with freqs&amp;probs-fn equal to combins-freqs-probs.
So, computes freqs and probs for each C in colls based on
combinations of coll items taken n at a time (the keys for the
maps).  Returns [ccfsps allfs allps cnt], where ccfsps is the seq
of triples for each C in colls, allfs is the map for all freqs,
allps is corresponding map for all probs and cnt is total count of
all elements.
</pre></div></div><div class="public anchor" id="var-cc-freqn"><h3>cc-freqn</h3><div class="usage"><code>(cc-freqn n colls &amp; {par :par, :or {par 1}})</code></div><div class="doc"><pre class="plaintext">cc-freqs for freqn - use freqn over colls
</pre></div></div><div class="public anchor" id="var-cc-freqs"><h3>cc-freqs</h3><div class="usage"><code>(cc-freqs n colls freq-fn &amp; {:keys [par], :or {par false}})</code></div><div class="doc"><pre class="plaintext">Frequencies of items in each collection in the collection of
collections colls.  Uses freq-fn to generate and count items.  Set
PAR to parallelize when (count colls) is large and each (freq-fn
c), c in colls, is expensive.  Returns a seq of frequency maps, one
for each collection in colls.
</pre></div></div><div class="public anchor" id="var-cc-freqs.26probs"><h3>cc-freqs&amp;probs</h3><div class="usage"><code>(cc-freqs&amp;probs n colls freqs&amp;probs-fn &amp; {:keys [par], :or {par false}})</code></div><div class="doc"><pre class="plaintext">For each C in colls (a collection of collecions), compute the
frequency and probability map for C and its total item count as
given by freqs&amp;probs-fn (for example, combins-freqs-probs).  Using
these maps, compute the total item frequency and probablity maps
and total count over all collections in colls.  Low level
functional base for public functions such as cc-freqs-probs,
et. al.

For large (count colls) with expensive freqs&amp;probs-fn, set par to
parallelize computation via vfold (and fork/join) using auto
partitioning

Return [ccfs&amp;ps allfs allps tcount], where

ccfs&amp;ps is a seq of triples [fs ps cnt], for each C in colls,
allfs is the map of freqs over all Cs,
allps is the map of probs over all Cs and
tcount is the total items over coll.
</pre></div></div><div class="public anchor" id="var-cc-freqs-probs"><h3>cc-freqs-probs</h3><div class="usage"><code>(cc-freqs-probs n colls &amp; {par :par, :or {par 1}})</code></div><div class="doc"><pre class="plaintext">cc-freqs&amp;probs using freqn as base frequency function
</pre></div></div><div class="public anchor" id="var-cc-tfreqn"><h3>cc-tfreqn</h3><div class="usage"><code>(cc-tfreqn n colls &amp; {par :par, :or {par 1}})</code></div><div class="doc"><pre class="plaintext">cc-tfreqs for freqn, cc-freqs with freqn plus overall totals.
</pre></div></div><div class="public anchor" id="var-cc-tfreqs"><h3>cc-tfreqs</h3><div class="usage"><code>(cc-tfreqs n colls freq-fn &amp; {par :par, :or {par 1}})</code></div><div class="doc"><pre class="plaintext">Same as cc-freqs, but also compute total item frequencies reduced
over all collections in colls.  Returns pair [ccfreqs cctfreqs],
where ccfreqs is the seq of frequency maps per cc-freqs and
cctfreqs is the single map for all items.
</pre></div></div><div class="public anchor" id="var-choose-k-freqn"><h3>choose-k-freqn</h3><div class="usage"><code>(choose-k-freqn n coll)</code></div><div class="doc"><pre class="plaintext">Synonym for combins-freqn
</pre></div></div><div class="public anchor" id="var-combin-count-reduction"><h3>combin-count-reduction</h3><div class="usage"><code>(combin-count-reduction item-coll sym)</code></div><div class="doc"><pre class="plaintext">Performs (freqn 1 item-coll), giving result M.  If sym is true,
coalesces items in M whose keys are reversible by retaining one key
with the sum of the values of previouis two.  See coalesce-xy-yx
for complete description.  This was originally a one off
specifically for coalescing combination sets (see combins), hence
the (now bogus) name.
</pre></div></div><div class="public anchor" id="var-combins-freqn"><h3>combins-freqn</h3><div class="usage"><code>(combins-freqn n coll &amp; {sym :sym, :or {sym true}})</code></div><div class="doc"><pre class="plaintext">Compute frequency map for coll where items are formed by all
choices of coll things taken n at a time: (combins n coll).  If SYM
is true (the default), treat vec/seq keys as symmetric.  Examples:

(combins-freqn
  2 "UUAAAAAACAAAAAAAAAAAACAAAACACAAAAACAAAUUCUACAAAAAAUAAAAACA")
{[\C \C] 28, [\A \C] 352, [\A \A] 946, [\U \C] 48,
 [\U \A] 264, [\U \U] 15}

(combins-freqn
  2 "UUAAAAAACAAAAAAAAAAAACAAAACACAAAAACAAAUUCUACAAAAAAUAAAAACA" :sym false
{[\C \U] 23, [\C \C] 28, [\C \A] 149, [\A \U] 131,
 [\A \C] 203, [\A \A] 946, [\U \C] 25, [\U \A] 133, [\U \U] 15}
</pre></div></div><div class="public anchor" id="var-combins-freqs-probs"><h3>combins-freqs-probs</h3><div class="usage"><code>(combins-freqs-probs n coll)</code></div><div class="doc"><pre class="plaintext">freqs&amp;probs with freq-fn equal to combins-freqn.  So, triple with
fs and ps maps based on combinations of coll items taken n at time,
i.e., keys are such items, with cnt element (nCk (count coll) n).</pre></div></div><div class="public anchor" id="var-cond-probability"><h3>cond-probability</h3><div class="usage"><code>(cond-probability PXY PY occurs?)</code><code>(cond-probability combinator sym? occurs? coll1 coll2)</code></div><div class="doc"><pre class="plaintext">Given collections coll1 and coll2, and combinator, a function of 2
variables which generates joint occurances from coll1 &amp; coll2,
returns the conditional probability distributions for coll1
conditioned on elements of coll2.  If sym? is true coalesce
reversable element occurances during joint occurance
computation.

Alternatively, in the distribution version, PXY is a joint
distribution in map form, and PY is a distribution in map form.
That is, in this variant, the probability distributions are
explicitly provided.

OCCURS? is a function of two variables, pkx and pkxy, where pkx is
a key derived from coll2/PY and pkxy is a key derived from the
combinator map of coll1 with coll2 or a key in PXY.  It returns
whether pkx occurs in pkxy.

cond-probability returns a map of maps, where each inner map is a
distribution of coll1 given ei in coll2:

{{ei {P(COLL1)|ei}} ei in COLL2.

Use pXY|y to obtain any given distribution, where y = some ei.

Examples:

(cond-probability
  transpose false #(= %1 (.charAt %2 1)) "defdeef" "abcaabb")
=&gt; {\a {"ea" 0.3333333333333333, "da" 0.6666666666666666},
    \b {"fb" 0.3333333333333333, "eb" 0.6666666666666666},
    \c {"fc" 0.9999999999999997}}

(cond-probability
  transpose false #(= %1 (.charAt %2 1)) "abcaabb" "defdeef")
=&gt; {\d {"ad" 1.0},
    \e {"ae" 0.3333333333333333, "be" 0.6666666666666666},
    \f {"bf" 0.5, "cf" 0.5}}
</pre></div></div><div class="public anchor" id="var-correlation"><h3>correlation</h3><div class="usage"><code>(correlation X Y)</code></div><div class="doc"><pre class="plaintext">For population/sample sets X and Y, compute the correlation between
X and Y, cor(X,Y).  The size of X and Y must be the same.  Provides
a 'measure' of the strength and connection of a linear relationship
beween X and Y.  Bounded by -1 (anti correlation) and 1 (perfect
correlation), i.e., cor(X,Y) in [-1, 1].  A value of zero indicates
no linear correlation, but does not mean independence, however
independence will produce a zero value.

  cor(X,Y) = (/ cov(X,Y) (* (std-deviation X) (std-deviation Y)))

Defined only if both standard deviations are nonzero.

Also known as Pearson correlation coefficient, Pearson
product-moment correlation, or simply Pearson correlation.

Correlation is a normalized covariance.
</pre></div></div><div class="public anchor" id="var-covariance"><h3>covariance</h3><div class="usage"><code>(covariance X Y)</code></div><div class="doc"><pre class="plaintext">For populations/sample sets X and Y, compute the covariance of X and Y,
cov(X,Y). The size of X and Y must be the same. Provides a
'measure' of how X and Y 'follow' one another or change together.
Do they both go up and down together, vice versa, or something in
between.

  let N (count X)
      mux (mean X)
      muy (mean Y)
   (sum (fn[xi yi] (/ (* (- xi mux) (- yi muy)) (dec N))) X Y)

   (the (dec N) would be just N, if using true populations)

   which, by some algebra, is E(XY) - E(X)E(Y).

Note: If X and Y are independent, E(XY) = E(X)E(Y) and so
covariance must be 0.  If X=Y, cov(X,X) = E(X^2)-E(X)^2 = var(X).

Note: a particular useful application is for the variance of a
linear combination of X &amp; Y:

 var(aX + bY) = a^2*E(X^2)+2ab*E(XY)+b^2*E(Y^2) -
                a^2*E(X)^2+2ab*E(X)E(Y)+b^2*E(Y)^2

              = a^2*(E(X^2)-E(X)^2) +
                b^2*(E(Y^2)-E(Y)^2) +
                2ab*(E(XY)-E(X)E(Y))

              = a^2*var(X)+b^2*var(Y)+2ab*cov(X,Y)

Note: cov is very dependent on the sample matching of X and Y, so
be sure X and Y are in the correct order on call:

 (covariance [1 2 3 4 5] [1 2 3 4 5])
 =&gt; 2.0
 (covariance [1 2 3 4 5] [2 1 4 3 5])
 =&gt; 1.6
 (covariance [1 2 3 4 5] [5 4 3 2 1])
 =&gt; -2.0

Bugs: not an unbiased estimator of population variance.
</pre></div></div><div class="public anchor" id="var-flatten-pair-coll"><h3>flatten-pair-coll</h3><div class="usage"><code>(flatten-pair-coll coll)</code></div><div class="doc"><pre class="plaintext">COLL is a collection of pairs [v w] where v is a value and w its
weight. For maps, keys are vs and values are ws.  Returns a lazy
seq of of the expansions as a single collection, with w repetitions
of v for each such [v w] pair.
</pre></div></div><div class="public anchor" id="var-freqn"><h3>freqn</h3><div class="usage"><code>(freqn n coll)</code></div><div class="doc"><pre class="plaintext">Frequencies of n-grams (aka kmers, "features", et. al.) in
collection COLL treated as a sequence.  n is the "window" or
resolution width.  Slide is always fixed at 1 (one) position.

 Ex: (freqn 2 "acagtcaacctggagcctggt")
 =&gt;
 {"aa" 1, "cc" 2, "gg" 2, "ac" 2, "ag" 2, "gt" 2,
 "tc" 1, "ct" 2, "tg" 2, "ga" 1, "gc" 1, "ca" 2}
</pre></div></div><div class="public anchor" id="var-freqs.26probs"><h3>freqs&amp;probs</h3><div class="usage"><code>(freqs&amp;probs n coll freq-fn)</code></div><div class="doc"><pre class="plaintext">Generate frequencies of items in coll by means (freq-fn n coll),
take those and compute the items' corresponding probabilities.
Return triple: [freqs probs cnt], where freqs and probs are maps
keyed by item and cnt is the total count of all items.  Lower level
functional base for more public functions freqs-probs, et.al.
</pre></div></div><div class="public anchor" id="var-freqs-probs"><h3>freqs-probs</h3><div class="usage"><code>(freqs-probs n coll)</code></div><div class="doc"><pre class="plaintext">freqs&amp;probs for n and coll with freq-fn equal freqn
</pre></div></div><div class="public anchor" id="var-geometric-dist"><h3>geometric-dist</h3><div class="usage"><code>(geometric-dist N p)</code></div><div class="doc"><pre class="plaintext">Geometric probability distribution.  P is the probability of an
event.  Return seq of pairs [k pr], where k in (range N) and pr is
probability of success after k failures.
</pre></div></div><div class="public anchor" id="var-geometric-pdf"><h3>geometric-pdf</h3><div class="usage"><code>(geometric-pdf p)</code></div><div class="doc"><pre class="plaintext">Return the geometric probability mass/distribution _function_
corresponding to p, the probability of a hit in some Bernoulli
trial.

The resulting function returned, call it gmpdf, is a function of
one parameter, the number of occurances K.  NOTE: gmpdf is only
defined for integer values.

So, if the result of (geometric-pdf 1/4) is bound to gmpdf,
then (gmpdf 3) would be the probability of getting a hit after 3
tries.  A distribution of gmpdf can then be generated via some
technique like:

(map pspdf (range 10))
</pre></div></div><div class="public anchor" id="var-joint-prob-x"><h3>joint-prob-x</h3><div class="usage"><code>(joint-prob-x Omega X Y &amp; {constr :constr, :or {constr true}})</code></div><div class="doc"><pre class="plaintext">Xperimental.  Not sure how to make this work in general while still
being useful.  Intent would be to supply sample space, random
variables X &amp; Y (as functions - including maps &amp; vectors), that
obey and/or define a constraint CONSTR, which may involve further
random variables.  Generate all joint occurances and from there the
joint probabilities.
</pre></div></div><div class="public anchor" id="var-joint-probability"><h3>joint-probability</h3><div class="usage"><code>(joint-probability combinator sym? coll)</code><code>(joint-probability combinator sym? coll1 coll2)</code><code>(joint-probability combinator sym? coll1 coll2 &amp; colls)</code></div><div class="doc"><pre class="plaintext">Given a set of collections c1, c2, c3, .. cn, and combinator, a
function of n variables which generates joint occurances from {ci},
returns the joint probability distribution.  If sym? is true
coalesce reversable element occurances.

Ex: (apply joint-probability
           transpose true (take 2 (seq/rotations "GGCGGAAGACCGCCUCGA")))
=&gt; {[\U \C] 0.11111111, [\A \G] 0.2777778, [\C \G] 0.2777778,
    [\A \C] 0.055555556, [\A \A] 0.055555556, [\G \G] 0.11111111,
    [\C \C] 0.11111111}

Ex: (joint-probability #(combins 2 %) true "GGCGGAAGACCGCCUCGA")
=&gt; {[\C \C] 0.09803921568627451, [\G \G] 0.13725490196078433,
    [\A \A] 0.0392156862745098, [\A \C] 0.1568627450980392,
    [\C \G] 0.27450980392156865, [\A \G] 0.1830065359477124,
    [\U \A] 0.026143790849673203, [\G \U] 0.0457516339869281,
    [\U \C] 0.0392156862745098}

Ex: (joint-probability
      (fn[X Y]
        (for [x X]
          (if (even? x)
              [:e (.charAt Y 0)]
              [(second (div x 3)) (rand-nth (rest Y))])))
      false
      (take 100 (iterate inc 0)) "abcde")
=&gt; {[2 \b] 0.04, [1 \b] 0.05, [2 \c] 0.04, [0 \b] 0.07, [1 \c] 0.05,
    [2 \d] 0.04, [0 \c] 0.05, [1 \d] 0.05, [2 \e] 0.04, [0 \d] 0.04,
    [1 \e] 0.02, [0 \e] 0.01, [:e \a] 0.5}
</pre></div></div><div class="public anchor" id="var-JPSxy"><h3>JPSxy</h3><div class="usage"><code>(JPSxy combinator coll)</code><code>(JPSxy combinator coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Joint Probability Symmetric: joint-probability with sym? true
</pre></div></div><div class="public anchor" id="var-JPxy"><h3>JPxy</h3><div class="usage"><code>(JPxy combinator coll)</code><code>(JPxy combinator coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Joint Probability non symmetric: joint-probability with sym? false
</pre></div></div><div class="public anchor" id="var-keysort"><h3>keysort</h3><div class="usage"><code>(keysort map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-letter-pairs"><h3>letter-pairs</h3><div class="usage"><code>(letter-pairs n s)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-mean"><h3>mean</h3><div class="usage"><code>(mean coll)</code><code>(mean x1 x2 &amp; xs)</code></div><div class="doc"><pre class="plaintext">Compute the expectaion of the collection COLL.  If coll is a number
keyed frequency map, computes as if seq of expansion of keys
weighted by frequency.  If coll is a simple map use (vals coll).
Also coll can be a collection of pairs [n w], where w is the weight
to assign to n.  Lastly, if single numbers are given, their weight
is taken as simply 1.  Effectively returns:

  let c* (flatten-pair-coll coll)
      cnt (count c*)
    (/ (sum c*) cnt)

But without computing actual weighted sequence c*.
</pre></div></div><div class="public anchor" id="var-median"><h3>median</h3><div class="usage"><code>(median coll)</code><code>(median x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Compute the median of the given collection COLL.  If coll is a
collection of number pairs [v w], where w is the weight for v,
effectively computes its median based on expansion of keys weighted
by frequency.  This includes frequency maps where keys are numbers
and values are their weights.  If coll is a simple map computes the
median of (vals coll).
</pre></div></div><div class="public anchor" id="var-num-key-freq-map.3F"><h3>num-key-freq-map?</h3><div class="usage"><code>(num-key-freq-map? x)</code></div><div class="doc"><pre class="plaintext">Returns true if X is a number keyed frequency map
</pre></div></div><div class="public anchor" id="var-p-value"><h3>p-value</h3><div class="usage"><code>(p-value d hits trials)</code></div><div class="doc"><pre class="plaintext">Compute p-value from distribution D and sample statistics x y
</pre></div></div><div class="public anchor" id="var-pair-coll.3F"><h3>pair-coll?</h3><div class="usage"><code>(pair-coll? x)</code></div><div class="doc"><pre class="plaintext">Returns true if X is a collection of number pairs.
</pre></div></div><div class="public anchor" id="var-pdsum"><h3>pdsum</h3><div class="usage"><code>(pdsum f pdf1 pdf2 &amp; pdfs)</code></div><div class="doc"><pre class="plaintext">NOT CURRENTLY USED.  REVISIT AND POSSIBLY ELIMINATE
</pre></div></div><div class="public anchor" id="var-pearson-correlation"><h3>pearson-correlation</h3><div class="usage"><code>(pearson-correlation X Y)</code></div><div class="doc"><pre class="plaintext">Often used synonym of correlation.  See correlation for details.
</pre></div></div><div class="public anchor" id="var-poisson-cdf"><h3>poisson-cdf</h3><div class="usage"><code>(poisson-cdf mu)</code></div><div class="doc"><pre class="plaintext">Return the Poisson cumulative probability _function_ corresponding
to mu, the mean or expected value of a random variable X over some
time/space interval.  In the Poisson case, the mean is also the
variance of X.

The resulting function returned, call it pscdf, is a function of
two parameters: lower limit l, and upper limit u, both &gt;= 0.  l and
u-1 are the minimum and maximum number of occurances, i.e., the
interval is the half open [0, u) interval.

Ex: If 2 bugs/week are introduced on average in statware, what is
the probability there will be less than 5 bugs introduced next
month.  So, mu = 2/week * 4 week = 8, l = 0 and u = 5:

((poisson-cdf 8) 0 5) =&gt; 0.0996 or about 10% chance.  Of course,
those dudes aren't using Clojure! :)
</pre></div></div><div class="public anchor" id="var-poisson-dist"><h3>poisson-dist</h3><div class="usage"><code>(poisson-dist N mu)</code></div><div class="doc"><pre class="plaintext">Poisson probability distribution. 
</pre></div></div><div class="public anchor" id="var-poisson-pdf"><h3>poisson-pdf</h3><div class="usage"><code>(poisson-pdf mu)</code></div><div class="doc"><pre class="plaintext">Return the Poisson probability mass/distribution _function_
corresponding to mu, the mean or expected value of a random
variable X over some time/space interval. In the Poisson case the
mean is also the variance of X.

The resulting function returned, call it pspdf, is a function of
one parameter, the number of occurances K.  NOTE: pspdf is only
defined for integer values.

So, if the result of (poisson-pdf 1.0) is bound to pspdf,
then (pspdf 3) would be the probability of getting 3 hits.  A
distribution of pspdf can then be generated via some technique
like: (map pspdf (range 1 (inc 100))).
</pre></div></div><div class="public anchor" id="var-poisson-sample"><h3>poisson-sample</h3><div class="usage"><code>(poisson-sample mu)</code><code>(poisson-sample N mu)</code></div><div class="doc"><pre class="plaintext">Generate a "random" sample from a Poisson distribution
characterized by mean/variance mu.  In the two parameter case,
generate N such samples.
</pre></div></div><div class="public anchor" id="var-probs"><h3>probs</h3><div class="usage"><code>(probs n coll)</code><code>(probs freq-dist-map)</code></div><div class="doc"><pre class="plaintext">Probabilities for items from coll taken n at a time (see freqn) or
as determined by the frequency dist map freq-dist-map.</pre></div></div><div class="public anchor" id="var-pXY.7Cy"><h3>pXY|y</h3><div class="usage"><code>(pXY|y XY y)</code></div><div class="doc"><pre class="plaintext">Given a total conditional distribution XY (see cond-probability),
 return the distribution of XY with respect to y.  XY should be a
 map of maps of the form returned from cond-probability.  Typically,
 this would be used in conjunction with cond-probability, but need
 not be as long as the form of the map of maps is the same, where
 each inner map is the joint distribution conditioned on an element.

 Ex:

 (pXY|y (cond-probability transpose false #(= %1 (.charAt %2 1))
                          "defdeef" "abcaabb")
        \a)
=&gt; {"ea" 0.3333333333333333, "da" 0.6666666666666666}
</pre></div></div><div class="public anchor" id="var-sampling"><h3>sampling</h3><div class="usage"><code>(sampling cnt dist)</code></div><div class="doc"><pre class="plaintext">First small step toward 'generic' sampler.  CNT is the size of the
sample to create.  DIST is some distribution over some event
space (aka omega).
</pre></div></div><div class="public anchor" id="var-std-deviation"><h3>std-deviation</h3><div class="usage"><code>(std-deviation coll)</code><code>(std-deviation coll &amp; {:keys [distfn avgfn v], :or {distfn -, avgfn mean}})</code></div><div class="doc"><pre class="plaintext">Compute the standard deviation of collection COLL.  If coll is a
map uses (vals coll).  Returns the sqrt of the variance of
coll. The functions distfn and avgfn are used for distances of
points in coll and the averaging function for the mean of
coll. These are used to compute the variance, or if V is given it
is taken as the variance and variance computation is skipped.  For
the single parameter case, distfn is '-' and avgfn is 'mean'.
</pre></div></div><div class="public anchor" id="var-variance"><h3>variance</h3><div class="usage"><code>(variance coll)</code><code>(variance coll &amp; {:keys [distfn avgfn m rfn], :or {distfn -, avgfn mean, rfn map}})</code></div><div class="doc"><pre class="plaintext">Compute the variance of the collection COLL.  If coll is a map
use (vals coll).  Returns average of squared differences of xs in
coll with 'mean' of coll.  The functions distfn and avgfn are used
for distances of points in coll and the averaging function.  Or,
the 'mean' can be given explicitly as M.

The rfn function is the 'reducer' function to use for calculating
the set of squared differences.  It defaults to 'map', but the user
can change this to some variant of fold, most typically vfold, to
parallelize the computation for large collections and/or expensive
distfns (such as various RE functions).

The single parameter case uses '-' as distfn and 'mean' as avgfn
and 'map' as the reducer.
</pre></div></div><div class="public anchor" id="var-word-letter-pairs"><h3>word-letter-pairs</h3><div class="usage"><code>(word-letter-pairs n s)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></body></html>