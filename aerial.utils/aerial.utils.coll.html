<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>aerial.utils.coll documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Aerial.utils</span> <span class="project-version">1.1.0</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to utils</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aerial</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></div></li><li class="depth-3 branch current"><a href="aerial.utils.coll.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coll</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ds</span></div></div></li><li class="depth-4 branch"><a href="aerial.utils.ds.bktrees.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bktrees</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.ds.graphs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graphs</span></div></a></li><li class="depth-4"><a href="aerial.utils.ds.trees.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>trees</span></div></a></li><li class="depth-3 branch"><a href="aerial.utils.io.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-3"><a href="aerial.utils.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.clustering.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clustering</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.combinatorics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combinatorics</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.infoth.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>infoth</span></div></a></li><li class="depth-4 branch"><a href="aerial.utils.math.probs-stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>probs-stats</span></div></a></li><li class="depth-4"><a href="aerial.utils.math.scores.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scores</span></div></a></li><li class="depth-3 branch"><a href="aerial.utils.misc.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>misc</span></div></a></li><li class="depth-3"><a href="aerial.utils.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="aerial.utils.coll.html#var-coalesce-xy-yx"><div class="inner"><span>coalesce-xy-yx</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-concatv"><div class="inner"><span>concatv</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-drop-until"><div class="inner"><span>drop-until</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-dropv"><div class="inner"><span>dropv</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-dropv-until"><div class="inner"><span>dropv-until</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-dropv-while"><div class="inner"><span>dropv-while</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-ensure-vec"><div class="inner"><span>ensure-vec</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-in"><div class="inner"><span>in</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-map-.3Ecsv-map"><div class="inner"><span>map-&gt;csv-map</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-map-entry.3F"><div class="inner"><span>map-entry?</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-merge-with*"><div class="inner"><span>merge-with*</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-mkseq"><div class="inner"><span>mkseq</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-partitionv-all"><div class="inner"><span>partitionv-all</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-pos"><div class="inner"><span>pos</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-pos-any"><div class="inner"><span>pos-any</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-positions"><div class="inner"><span>positions</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-pxmap"><div class="inner"><span>pxmap</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-random-subset"><div class="inner"><span>random-subset</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-reducem"><div class="inner"><span>reducem</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-rotate"><div class="inner"><span>rotate</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-rotations"><div class="inner"><span>rotations</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-separate"><div class="inner"><span>separate</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-separatev"><div class="inner"><span>separatev</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-sliding-take"><div class="inner"><span>sliding-take</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-splitv-at"><div class="inner"><span>splitv-at</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-subsets"><div class="inner"><span>subsets</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-take-until"><div class="inner"><span>take-until</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-take-until-nochange"><div class="inner"><span>take-until-nochange</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-takev"><div class="inner"><span>takev</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-takev-until"><div class="inner"><span>takev-until</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-takev-while"><div class="inner"><span>takev-while</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-third"><div class="inner"><span>third</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-transpose"><div class="inner"><span>transpose</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-vfold"><div class="inner"><span>vfold</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-xfold"><div class="inner"><span>xfold</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-xprod"><div class="inner"><span>xprod</span></div></a></li><li class="depth-1"><a href="aerial.utils.coll.html#var-xprod-rng1k"><div class="inner"><span>xprod-rng1k</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">aerial.utils.coll</h1><div class="doc"><pre class="plaintext">Various supplementary collection functions not included in the
dstandard Clojure ecosystem.  Mostly for seqs, but also for
vectors, maps and sets.</pre></div><div class="public anchor" id="var-coalesce-xy-yx"><h3>coalesce-xy-yx</h3><div class="usage"><code>(coalesce-xy-yx item-coll f)</code></div><div class="doc"><pre class="plaintext">Coaleseces elements of item-coll, which are or have common &quot;keys&quot;,
according to the function f.  Two keys k1 and k2 are considered
common if (or (= k1 k2) (= (reverse k1) k2)) for reversible keys or
simply (= k1 k2) for non reversible keys.  Reversible keys are
vectors, seqs, or string types.

F is a function of two parameters [x v], where x is an element of
item-coll, and v is the current value associated with the key of x
or nil if no association yet exists.  F is expected to return the
current association for key of x based on x and v.  If x is a
mapentry, (key x) is used to determine the association.  If x is a
list or vector (first x) is used to determine the association.

Ex:
(freqn 1 (map #(apply str %) (combins 2 &quot;auauuagcgccg&quot;)))
=&gt; {&quot;aa&quot; 3, &quot;cc&quot; 3, &quot;gg&quot; 3, &quot;uu&quot; 3, &quot;ac&quot; 9, &quot;cg&quot; 4,
    &quot;ag&quot; 9, &quot;ua&quot; 4, &quot;uc&quot; 9, &quot;ug&quot; 9, &quot;au&quot; 5, &quot;gc&quot; 5}

(coalesce-xy-yx *1 (fn[x v] (if (not v) 0 (+ (val x) v))))
=&gt; {&quot;aa&quot; 3, &quot;cc&quot; 3, &quot;gg&quot; 3, &quot;uu&quot; 3, &quot;ac&quot; 9, &quot;cg&quot; 9,
    &quot;ag&quot; 9, &quot;ua&quot; 9, &quot;uc&quot; 9, &quot;ug&quot; 9}
</pre></div></div><div class="public anchor" id="var-concatv"><h3>concatv</h3><div class="usage"><code>(concatv)</code><code>(concatv coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Eager concat. WARNING: Use with caution on large colls. Will
infinite loop on infinite colls!</pre></div></div><div class="public anchor" id="var-drop-until"><h3>drop-until</h3><div class="usage"><code>(drop-until pred coll)</code></div><div class="doc"><pre class="plaintext">Complement of drop-while
</pre></div></div><div class="public anchor" id="var-dropv"><h3>dropv</h3><div class="usage"><code>(dropv n coll)</code></div><div class="doc"><pre class="plaintext">Eager drop. Uses transducers to eagerly drop from a coll

WARNING: Use with caution on large colls. Will infinite loop on
infinite colls!
</pre></div></div><div class="public anchor" id="var-dropv-until"><h3>dropv-until</h3><div class="usage"><code>(dropv-until pred coll)</code></div><div class="doc"><pre class="plaintext">Eager drop-until. Uses transducers to eagerly drop from a coll

WARNING: Use with caution on large colls. May infinite loop on
infinite colls!
</pre></div></div><div class="public anchor" id="var-dropv-while"><h3>dropv-while</h3><div class="usage"><code>(dropv-while pred coll)</code></div><div class="doc"><pre class="plaintext">Eager drop-while. Uses transducers to eagerly drop from a coll

WARNING: Use with caution on large colls. May infinite loop on
infinite colls!
</pre></div></div><div class="public anchor" id="var-ensure-vec"><h3>ensure-vec</h3><div class="usage"><code>(ensure-vec x)</code></div><div class="doc"><pre class="plaintext">Return a vector representation for x.  If x is a vector just return
it, if it is a seqable return (vec x), if it is an &quot;atom&quot; return
[x].</pre></div></div><div class="public anchor" id="var-in"><h3>in</h3><div class="usage"><code>(in e coll)</code></div><div class="doc"><pre class="plaintext">Return whether e is an element of coll.
</pre></div></div><div class="public anchor" id="var-map-.3Ecsv-map"><h3>map-&gt;csv-map</h3><div class="usage"><code>(map-&gt;csv-map map)</code><code>(map-&gt;csv-map prefix map)</code></div><div class="doc"><pre class="plaintext">Transforms a nested map into a &quot;flattened&quot; map where keys are
column names formed by concatenating the path of keys to each
element. If prefix is given it is catenated to the front of each
column name.

Ex:

(map-&gt;csv-map {:one {:a 1 :b 2}, :two {&quot;hi&quot; 1 &quot;there&quot; 7}})
=&gt; {&quot;one_a&quot; [1], &quot;one_b&quot; [2], &quot;two_hi&quot; [1], &quot;two_there&quot; [7]}

(map-&gt;csv-map &quot;P&quot; {:one {:a 1 :b 2}, :two {&quot;hi&quot; 1 &quot;there&quot; 7}})
=&gt; {&quot;P_one_a&quot; [1], &quot;P_one_b&quot; [2], &quot;P_two_hi&quot; [1], &quot;P_two_there&quot; [7]}
</pre></div></div><div class="public anchor" id="var-map-entry.3F"><h3>map-entry?</h3><div class="usage"><code>(map-entry? x)</code></div><div class="doc"><pre class="plaintext">Return whether x is a map entry
</pre></div></div><div class="public anchor" id="var-merge-with*"><h3>merge-with*</h3><h4 class="added">added in 1.jsa</h4><div class="usage"><code>(merge-with* f &amp; maps)</code></div><div class="doc"><pre class="plaintext">Merge-with needs to call user supplied F with the KEY as well!!!
Returns a map that consists of the rest of the maps conj-ed onto the
first.  If a key occurs in more than one map, the mapping(s) from
the latter (left-to-right) will be combined with the mapping in the
result by calling (f key val-in-result val-in-latter).</pre></div></div><div class="public anchor" id="var-mkseq"><h3>mkseq</h3><div class="usage"><code>(mkseq x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-partitionv-all"><h3>partitionv-all</h3><div class="usage"><code>(partitionv-all n coll)</code></div><div class="doc"><pre class="plaintext">Eager partition-all. Uses transducers to eagerly partition coll
into partitions of size n (with possibly fewer than n items at the
end).

WARNING: use with caution on large colls. Will infinite loop on
infinite colls!
</pre></div></div><div class="public anchor" id="var-pos"><h3>pos</h3><div class="usage"><code>(pos x coll)</code></div><div class="doc"><pre class="plaintext">Returns a lazy seq of positions of X within COLL taken as a sequence
</pre></div></div><div class="public anchor" id="var-pos-any"><h3>pos-any</h3><div class="usage"><code>(pos-any test-coll coll)</code></div><div class="doc"><pre class="plaintext">Returns a lazy seq of positions of any element of TEST-COLL within
COLL taken as a sequence</pre></div></div><div class="public anchor" id="var-positions"><h3>positions</h3><div class="usage"><code>(positions pred coll)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-pxmap"><h3>pxmap</h3><div class="usage"><code>(pxmap f par coll)</code><code>(pxmap f par coll1 coll2)</code><code>(pxmap f par coll1 coll2 &amp; colls)</code></div><div class="doc"><pre class="plaintext">Constrained pmap.  Constrain pmap to at most par threads.
Generally, to ensure non degrading behavior, par should be
&lt;= (.. Runtime getRuntime availableProcessors).  It can be more,
but if par &gt;&gt; availableProcessors, thrashing (excessive context
switching) can become an issue.  Nevertheless, there are cases
where having par be larger can reduce the ill effects of the
partition problem.  NOTE: no effort is made to provide the true (or
even a &quot;good&quot;) solution to the partitioning of f over coll(s).

Effectively, (pmap f (partition-all (/ (count coll) par) coll).
Implicit doall on results to force execution.  For multiple
collection variants, chunks the _transpose_ of the collection of
collections.
</pre></div></div><div class="public anchor" id="var-random-subset"><h3>random-subset</h3><div class="usage"><code>(random-subset s n)</code></div><div class="doc"><pre class="plaintext">Create a &quot;random&quot; N element subset of the collection s treated as a set,
i.e., s with no duplicate elements.  If n &lt;= 0, return #{}, the
empty set.  If (count (set s)) &lt;= n, return (set s).  Otherwise,
pick N random elements from (set s) to form subset.
</pre></div></div><div class="public anchor" id="var-reducem"><h3>reducem</h3><div class="usage"><code>(reducem f fr coll)</code><code>(reducem f fr coll1 &amp; colls)</code></div><div class="doc"><pre class="plaintext">Multiple collection reduction. FR is a reducing function which must
return an identity value when called with no arguments. F is a
transform function that is applied to the arguments from the
supplied collections (treated as seqs).  Note, for the first
application, the result is (fr (fr) (f ...)).

By default, reduction proceeds on the results of F applied over the
_cross product_ of the collections.  If reduction should proceed
over collections in parallel, the first &quot;coll&quot; given should be
the special keyword :||.  If given, this causes F to be applied to
the elements of colls as stepped in parallel: f(coll1[i] coll2[i]
.. colln[i]), i in [0 .. (count smallest-given-coll)].
</pre></div></div><div class="public anchor" id="var-rotate"><h3>rotate</h3><div class="usage"><code>(rotate coll)</code><code>(rotate n coll)</code></div><div class="doc"><pre class="plaintext">Rotate (seq coll) by n positions. In single arg case, n=1.
</pre></div></div><div class="public anchor" id="var-rotations"><h3>rotations</h3><div class="usage"><code>(rotations x)</code></div><div class="doc"><pre class="plaintext">Returns a lazy seq of all rotations of a seq
</pre></div></div><div class="public anchor" id="var-separate"><h3>separate</h3><div class="usage"><code>(separate f s)</code></div><div class="doc"><pre class="plaintext">Returns a vector:
[(filter f s), (filter (complement f) s) ]</pre></div></div><div class="public anchor" id="var-separatev"><h3>separatev</h3><div class="usage"><code>(separatev f s)</code></div><div class="doc"><pre class="plaintext">Eager separate, returns [(filterv f s) (filterv (complement f) s)]

WARNING: Uses eager drop - use with caution on large colls. Will
infinite loop on infinite colls!
</pre></div></div><div class="public anchor" id="var-sliding-take"><h3>sliding-take</h3><div class="usage"><code>(sliding-take n coll)</code><code>(sliding-take d n coll)</code></div><div class="doc"><pre class="plaintext">Sliding window take. N is the &quot;window&quot; size to slide across
collection COLL treated as a sequence. D is the slide displacement
and defaults to 1.</pre></div></div><div class="public anchor" id="var-splitv-at"><h3>splitv-at</h3><div class="usage"><code>(splitv-at n coll)</code></div><div class="doc"><pre class="plaintext">Eager split. Uses transducers to eagerly split a coll a pos n.

WARNING: Uses eager drop - use with caution on large colls. Will
infinite loop on infinite colls!
</pre></div></div><div class="public anchor" id="var-subsets"><h3>subsets</h3><div class="usage"><code>(subsets coll)</code></div><div class="doc"><pre class="plaintext">All the subsets of elements of coll
</pre></div></div><div class="public anchor" id="var-take-until"><h3>take-until</h3><div class="usage"><code>(take-until pred coll)</code></div><div class="doc"><pre class="plaintext">Complement of take-while
</pre></div></div><div class="public anchor" id="var-take-until-nochange"><h3>take-until-nochange</h3><div class="usage"><code>(take-until-nochange sq &amp; {:keys [elt=], :or {elt= =}})</code></div><div class="doc"><pre class="plaintext">Eagerly takes from SQ until consecutive elements are the same.  So,
take until and up to element Ei, where Ei=Ei+1.  Equality of
elements is determined by elt=, which defaults to =.
</pre></div></div><div class="public anchor" id="var-takev"><h3>takev</h3><div class="usage"><code>(takev n coll)</code></div><div class="doc"><pre class="plaintext">Eager take. Uses transducers to eagerly take from a coll
</pre></div></div><div class="public anchor" id="var-takev-until"><h3>takev-until</h3><div class="usage"><code>(takev-until pred coll)</code></div><div class="doc"><pre class="plaintext">Eager take-until. Uses transducers to eagerly take from a coll

WARNING: Use with caution on large colls. May infinite loop on
infinite colls!
</pre></div></div><div class="public anchor" id="var-takev-while"><h3>takev-while</h3><div class="usage"><code>(takev-while pred coll)</code></div><div class="doc"><pre class="plaintext">Eager take-while. Uses transducers to eagerly take from a coll

WARNING: Use with caution on large colls. May infinite loop on
infinite colls!
</pre></div></div><div class="public anchor" id="var-third"><h3>third</h3><div class="usage"><code>(third coll)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-transpose"><h3>transpose</h3><div class="usage"><code>(transpose colls)</code><code>(transpose coll1 coll2 &amp; colls)</code></div><div class="doc"><pre class="plaintext">Matrix transposition.  Well, effectively.  Can be used in some
other contexts, but does the same computation.  Takes colls a
collection of colletions, treats this as a matrix of (count colls)
rows, each row being a string or seqable data structure: M[rij],
where rij is the jth element of the ith row.  Returns M&apos; = M[cji],
where cji is the ith element of the jth column of M.

For the cases where colls is a string or a collection of strings,
returns M with rows as strings (effectively M[(apply str cji)]).
</pre></div></div><div class="public anchor" id="var-vfold"><h3>vfold</h3><div class="usage"><code>(vfold f coll)</code><code>(vfold f n coll)</code><code>(vfold f n coll &amp; colls)</code></div><div class="doc"><pre class="plaintext">Fold function f over a collection or set of collections (c1, ...,
cn) producing a collection (concrete type of vector).  Arity of f
must be equal to the number of collections being folded with
parameters matching the order of the given collections.  Folding
here uses the reducer lib fold at base, and thus uses work stealing
deque f/j to mostly relieve the partition problem.  In signatures
with N given, N provides the packet granularity, or if (&lt; N 1),
granularity is determined automatically (see below) as in the
base (non N case) signature.

While vfold is based on r/fold, it abstracts over the combiner,
reducer, work packet granularity, and transforming multiple
collections for processing by f by chunking the _transpose_ of the
collection of collections.

As indicated above, vfold&apos;s fold combiner is monoidal on vectors:
it constructs a new vector from an l and r vector, and has identity
[] (empty vector).  In line with this, vfold&apos;s reducer builds up
new vectors from elements by conjing (f a1, ... an) onto a prior
result or the combiner identity, [], as initial result.

Packet granularity is determined automatically (base case or N=0)
or supplied with N &gt; 1 in signatures with N.  Automatic
determination tries to balance significant work chunks (keep thread
overhead low), with chunks that are small enough to have multiple
instances per worker queue (supporting stealing by those workers
that finish ahead of others).
</pre></div></div><div class="public anchor" id="var-xfold"><h3>xfold</h3><div class="usage"><code>(xfold &amp; args)</code></div><div class="doc"><pre class="plaintext">Deprecated! Use vfold!!!
</pre></div></div><div class="public anchor" id="var-xprod"><h3>xprod</h3><div class="usage"><code>(xprod k coll)</code><code>(xprod xfn k coll)</code></div><div class="doc"><pre class="plaintext">Cross product item generation of size K over COLL. xfn is a
transform function applied to each item set generated, and defaults
to simply aggregating them in a vector.

Examples:
(xprod 2 &quot;ADN&quot;)
=&gt; [[\A \A] [\A \D] [\A \N] [\D \A] [\D \D]
    [\D \N] [\N \A] [\N \D] [\N \N]]
(xprod str 2  &quot;ADN&quot;)
=&gt; [&quot;AA&quot; &quot;AD&quot; &quot;AN&quot; &quot;DA&quot; &quot;DD&quot; &quot;DN&quot; &quot;NA&quot; &quot;ND&quot; &quot;NN&quot;]</pre></div></div><div class="public anchor" id="var-xprod-rng1k"><h3>xprod-rng1k</h3><div class="usage"><code>(xprod-rng1k k coll)</code><code>(xprod-rng1k xfn k coll)</code></div><div class="doc"><pre class="plaintext">Cross product item generation ranging from size 1 to K over
COLL. The cross products for each size are concatenated in order.
xfn is a transform function applied to each item set generated, and
defaults to simply aggregating them in a vector.

Examples:
(xprod-rng1k 1 &quot;ADN&quot;)
=&gt; ([\A] [\D] [\N])
(xprod-rng1k 2 &quot;ADN&quot;)
=&gt; ([\A] [\D] [\N] [\A \A] [\A \D] [\A \N] [\D \A] [\D \D]
    [\D \N] [\N \A] [\N \D] [\N \N])
(xprod-rng1k str 3 &quot;ADN&quot;)
=&gt; (&quot;A&quot; &quot;D&quot; &quot;N&quot; &quot;AA&quot; &quot;AD&quot; &quot;AN&quot; &quot;DA&quot; &quot;DD&quot;
    &quot;DN&quot; &quot;NA&quot; &quot;ND&quot; &quot;NN&quot; &quot;AAA&quot; &quot;AAD&quot; &quot;AAN&quot;
    &quot;ADA&quot; &quot;ADD&quot; &quot;ADN&quot; &quot;ANA&quot; &quot;AND&quot; &quot;ANN&quot; &quot;DAA&quot;
    &quot;DAD&quot; &quot;DAN&quot; &quot;DDA&quot; &quot;DDD&quot; &quot;DDN&quot; &quot;DNA&quot; &quot;DND&quot;
    &quot;DNN&quot; &quot;NAA&quot; &quot;NAD&quot; &quot;NAN&quot; &quot;NDA&quot; &quot;NDD&quot; &quot;NDN&quot;
    &quot;NNA&quot; &quot;NND&quot; &quot;NNN&quot;)</pre></div></div></div></body></html>